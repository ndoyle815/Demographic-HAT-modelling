
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                                                               %
%   This code computes the passive-only endemic equilibrium of the Warwick HAT model                            %
%                                                                                                               %
%   Inputs:                                                                                                     %
%       N_H - number denoting human population size used in ODE                                                 %
%       Paras - structure containing location-specific parameters (fixed, fitted and intervention parameters)   %
%                                                                                                               %
%   Outputs:                                                                                                    %
%       meff - number denoting effective vector density, calculated by the relation Paras.R0^2 ~ meff           %
%       ICs - cell array containing endemic equilibrium of given set of parameters                              %
%                                                                                                               %
%   Note: ICs will be used as the initial conditions to run the HAT dynamics for computing the Likelihood of    %
%         Sampling Parameters generated by MCMC algorithm                                                       %
%                                                                                                               %
%         hosts are (1) low-risk, random participants                                                           %
%                   (2) high-risk, random participants                                                          %
%                   (3) low-risk, non-participants                                                              %
%                   (4) high-risk, non-participants                                                             %
%                   (5) reservoir animals                                                                       %
%                   (6) non-reservoir animals, no dynamics and is ignored                                       %
%                                                                                                               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [meff, ICs] = GetEndemicEq(N_H, Paras, Data)
% ELLIOT NOTE this function now needs to take in Data, so that needs
% changing both here and in the other scripts
    
    % bite rates
    k=[Data.N_FY./Data.N_H Data.N_FW./Data.N_H Data.N_FP./Data.N_H Data.N_MY./Data.N_H Data.N_MW./Data.N_H Data.N_MP./Data.N_H Paras.k_A 1];
    
    s_A = 0;
    s_N = 0;
    bitepref=[1 Paras.rFW Paras.rFP Paras.rMY Paras.rMW Paras.rMP s_A s_N];            %biting preference on hosts (given no animal reservoir)  
    f=(bitepref.*k)/sum(bitepref.*k).*Paras.f_H;
    f(8) = [];
    f(7) = [];

    eta_H0 = Paras.eta_H * Paras.b_eta_H0; % Fixed as 0 in Paras.mat


    %%% Compute m_eff using NGM approach, where the order of matrix elements is
    %%% (E_H (of all demog), I1_H (of all demog), I2_H (of all demog) demog order is FY FW FP MY MW MP, then   E1_V, E2_V, E3_V, I_V
    T = zeros(22,22);
    S = zeros(22,22);
    S_Vstar = Paras.mu_V * N_H / (Paras.alpha + Paras.mu_V); % equilibrium S_V
    G_Vfrom0 = Paras.alpha * N_H / (Paras.alpha + Paras.mu_V); % equilibrium (no infection) G_V

    meff = 1; % assign a value for computing the corresponding R_0

    %T is transmissions
    T(1,22) = Paras.alpha * meff * f(1);
    T(2,22) = Paras.alpha * meff * f(2);
    T(3,22) = Paras.alpha * meff * f(3);
    T(4,22) = Paras.alpha * meff * f(4);
    T(5,22) = Paras.alpha * meff * f(5);
    T(6,22) = Paras.alpha * meff * f(6);

    T(19,7) = Paras.alpha * f(1) * Paras.p_V * (S_Vstar + Paras.epsilon * G_Vfrom0) / Data.N_FY;
    T(19,8) = Paras.alpha * f(2) * Paras.p_V * (S_Vstar + Paras.epsilon * G_Vfrom0) / Data.N_FW;
    T(19,9) = Paras.alpha * f(3) * Paras.p_V * (S_Vstar + Paras.epsilon * G_Vfrom0) / Data.N_FP;
    T(19,10) =  Paras.alpha * f(4) * Paras.p_V * (S_Vstar + Paras.epsilon * G_Vfrom0) / Data.N_MY;
    T(19,11) =  Paras.alpha * f(5) * Paras.p_V * (S_Vstar + Paras.epsilon * G_Vfrom0) / Data.N_MW;
    T(19,12) =  Paras.alpha * f(6) * Paras.p_V * (S_Vstar + Paras.epsilon * G_Vfrom0) / Data.N_MP;
    T(19,13:18) = T(19,7:12);


    %S is transitions (including passive stage1 detection)
    % NATHAN
    % E_H
    S(1,1) = - (Paras.sigma_H + Paras.mu_H_FY + Paras.l_Y);
    S(2,2) = - (Paras.sigma_H + Paras.mu_H_FW + Paras.l_W);
    S(3,3) = - (Paras.sigma_H + Paras.mu_H_FP);
    S(4,4) = - (Paras.sigma_H + Paras.mu_H_MY + Paras.l_Y);
    S(5,5) = - (Paras.sigma_H + Paras.mu_H_MW + Paras.l_W);
    S(6,6) = - (Paras.sigma_H + Paras.mu_H_MP);
    S(2,1) = Paras.l_Y;
    S(3,2) = Paras.l_W;
    S(5,4) = S(2,1);
    S(6,5) = S(3,2);

    % I1_H
    S(7,7) = - (eta_H0 + Paras.phi_H + Paras.mu_H_FY + Paras.l_Y);
    S(8,8) = - (eta_H0 + Paras.phi_H + Paras.mu_H_FW + Paras.l_W);
    S(9,9) = - (eta_H0 + Paras.phi_H + Paras.mu_H_FP);
    S(10,10) = - (eta_H0 + Paras.phi_H + Paras.mu_H_MY + Paras.l_Y);
    S(11,11) = - (eta_H0 + Paras.phi_H + Paras.mu_H_MW + Paras.l_W);
    S(12,12) = - (eta_H0 + Paras.phi_H + Paras.mu_H_MP);
    S(8,7) = S(2,1);
    S(9,8) = S(3,2);
    S(11,10) = S(2,1);
    S(12,11) = S(3,2);
    S(7,1) = Paras.sigma_H;
    S(8,2) = S(7,1);
    S(9,3) = S(7,1);
    S(10,4) = S(7,1);
    S(11,5) = S(7,1);
    S(12,6) = S(7,1);

    % I2_H
    S(13,13) = - (Paras.gamma_H0 + Paras.mu_H_FY + Paras.l_Y);
    S(14,14) = - (Paras.gamma_H0 + Paras.mu_H_FW + Paras.l_W);
    S(15,15) = - (Paras.gamma_H0 + Paras.mu_H_FP);
    S(16,16) = - (Paras.gamma_H0 + Paras.mu_H_MY + Paras.l_Y);
    S(17,17) = - (Paras.gamma_H0 + Paras.mu_H_MW + Paras.l_W);
    S(18,18) = - (Paras.gamma_H0 + Paras.mu_H_MP);
    S(14,13) = S(2,1);
    S(15,14) = S(3,2);
    S(17,16) = S(2,1);
    S(18,17) = S(3,2);
    S(13,7) = Paras.phi_H;
    S(14,8) = S(13,7);
    S(15,9) = S(13,7);
    S(16,10) = S(13,7);
    S(17,11) = S(13,7);
    S(18,12) = S(13,7);
    
    % Tsetse (transitions unchanged)
    S(19,19) = - 3 * Paras.sigma_V - Paras.mu_V; % leaves E1_V
    S(20,19) =  3 * Paras.sigma_V; % enters E2_V from E1_V
    S(20,20) = - 3 * Paras.sigma_V - Paras.mu_V; % leaves E2_V
    S(21,20) = 3 * Paras.sigma_V; % enters E3_V from E2_V
    S(21,21) = - 3 * Paras.sigma_V - Paras.mu_V; % leaves E3_V
    S(22,21) = 3 * Paras.sigma_V; % enters I_V from E3_V
    S(22,22) = - Paras.mu_V; % leaves I_V

    % Compute NGM
    K = - T * inv(S);
    R0_current = max(abs(eig(K)));
    meff=(Paras.R0/R0_current)^2 * meff;


    % ELLIOT The below is getting endemic eq by running to steady state

    %%% Compute Endemic Equilibrium
    ODEoptions = odeset('NonNegative', 1:37);
    parameter = Paras;
    parameter.f = f';
    parameter.meff = meff;
    parameter.mu_H = [Paras.mu_H_FY Paras.mu_H_FW Paras.mu_H_FP Paras.mu_H_MY Paras.mu_H_MW Paras.mu_H_MP]';
    parameter.sigma_H = [Paras.sigma_H*ones(1,6)]';
    parameter.phi_H = [Paras.phi_H*ones(1,6)]';
    parameter.omega_H = [Paras.omega_H*ones(1,6)]';
    parameter.K_V = Data.N_H * Paras.mu_V / (Paras.xi_V^2 * Paras.p_survive * (Paras.p_survive * Paras.B_V / Paras.mu_V - 1));
        
    parameter.gamma_H = [Paras.gamma_H0*ones(1,6)]';
    parameter.eta_H = [eta_H0*ones(1,6)]';

    
    pop = zeros(1,37); 
    pop(end+1,:) = [Data.N_FY*0.99, Data.N_FW*0.99, Data.N_FP*0.99, Data.N_MY*0.99, Data.N_MW*0.99, Data.N_MP*0.99, ...
                    Data.N_FY*0.01, Data.N_FW*0.01, Data.N_FP*0.01, Data.N_MY*0.01, Data.N_MW*0.01, Data.N_MP*0.01, ...
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Data.N_H*meff/3, Data.N_H*meff/3, Data.N_H*meff/3, 0, 0, 0, 0];

%     % Elliot: We need to decide on a good threshold value for when its at SS
%     % I've just set 0.01 for now
    
    %ICs1 = [Data.N_FY*0.99, Data.N_FW*0.99, Data.N_FP*0.99, Data.N_MY*0.99, Data.N_MW*0.99, Data.N_MP*0.99, ...
    %        Data.N_FY*0.01, Data.N_FW*0.01, Data.N_FP*0.01, Data.N_MY*0.01, Data.N_MW*0.01, Data.N_MP*0.01, ...
    %        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Data.N_H*meff];

    %tic
    %fsolve(@(x)diffHATmodel(t, x, parameter),ICs1)
    %toc
    while any(abs( pop(end,1:18) - pop(end - 1,1:18)) > 1 )
        ICs1 = pop(end,:);
        tic
        [t, pop] = ode45(@diffHATmodel, [0:1:1*365], ICs1, ODEoptions, parameter);
        %toc
    end
    %toc
    ICs = {pop(end,1:6), pop(end,7:12), pop(end,13:18), pop(end,19:24), pop(end,25:30), pop(end,31), pop(end,32), pop(end,33), pop(end,34), pop(end,35), pop(end,36), pop(end,37)};
   % [ICs{6}, ICs{7}, ICs{8},    ICs{9},    ICs{10},    ICs{11},   ICs{12}]
    %ICs
    % Main ODE code - copy and pasted from HATODEmodel.m
    function dPop = diffHATmodel(t, pop, parameter) % M9

    %Compute vector reduction function
    %f_T = parameter.p_targetdie * (1 - sigmf(mod(t,365/parameter.TargetFreq),[25/365 0.35*365]));
    f_T = 0;

    %Get populations from inputs
    S_H = pop(1:6); E_H = pop(7:12); I1_H = pop(13:18); I2_H = pop(19:24); R_H = pop(25:30);
    P_V = pop(31); S_V = pop(32); G_V = pop(33); E1_V=pop(34); E2_V=pop(35); E3_V=pop(36); I_V=pop(37);

    N_H = S_H + E_H + I1_H + I2_H + R_H;
    N_V = S_V + G_V + E1_V + E2_V + E3_V + I_V;

    dNH = N_H;
    dNH(N_H==0) = 1;

    %Human infection dynamics 
    age_out_rate = [Paras.l_Y Paras.l_W 0 Paras.l_Y Paras.l_W 0]';
    age_in_rate = [0 Paras.l_Y Paras.l_W 0 Paras.l_Y Paras.l_W]';

    in_idx = [3,1,2,6,4,5];

    dS_H = age_in_rate .* S_H(in_idx) + parameter.omega_H .* R_H  + parameter.omega_IB .* I1_H - I_V * parameter.alpha * parameter.meff .* parameter.f .* S_H ./ dNH - parameter.mu_H .* S_H - age_out_rate .* S_H;
    dE_H = age_in_rate .* E_H(in_idx) + I_V * parameter.alpha * parameter.meff .* parameter.f .* S_H ./ dNH - (parameter.sigma_H + parameter.mu_H) .* E_H - age_out_rate .* E_H;
    dI1_H = age_in_rate .* I1_H(in_idx) + parameter.sigma_H .* E_H * parameter.p_BS - (parameter.eta_H + parameter.phi_H + parameter.mu_H + parameter.omega_IB) .* I1_H  - age_out_rate .* I1_H;
    dI2_H = age_in_rate .* I2_H(in_idx) + parameter.phi_H .* I1_H -  (parameter.gamma_H + parameter.mu_H) .* I2_H  - age_out_rate .* I2_H;
    dR_H =  age_in_rate .* R_H(in_idx) + parameter.eta_H .* I1_H + parameter.gamma_H .* I2_H - (parameter.omega_H + parameter.mu_H) .* R_H - age_out_rate .* R_H;

    dS_H(1) = dS_H(1) + sum(parameter.mu_H(1:3) .* N_H(1:3));
    dS_H(4) = dS_H(4) + sum(parameter.mu_H(4:6) .* N_H(4:6));


    %Tsetse Infection dynamics
    %Pupa
    dP_V = parameter.B_V * N_V - (parameter.xi_V + P_V/parameter.K_V) * P_V;
    %Teneral
    dS_V = parameter.xi_V * parameter.p_survive * P_V - parameter.alpha * S_V - parameter.mu_V * S_V;
    %Non-teneral
    dG_V = parameter.alpha * (1 - f_T) * (1 - sum(parameter.f .* (I1_H + I2_H) ./ dNH) * parameter.p_V) * S_V - parameter.alpha * ((1 - f_T) * parameter.epsilon * sum(parameter.f .* (I1_H + I2_H) ./ dNH) * parameter.p_V + f_T) * G_V - parameter.mu_V * G_V;
    %Exposed
    dE1_V = parameter.alpha * (1 - f_T) * sum(parameter.f .* (I1_H + I2_H) ./ dNH) * parameter.p_V * (S_V + parameter.epsilon * G_V) - 3 * parameter.sigma_V * E1_V - (parameter.mu_V + parameter.alpha * f_T) * E1_V;
    dE2_V = 3 * parameter.sigma_V * E1_V - (3 * parameter.sigma_V + parameter.mu_V + parameter.alpha * f_T) * E2_V;
    dE3_V = 3 * parameter.sigma_V * E2_V - (3 * parameter.sigma_V + parameter.mu_V + parameter.alpha * f_T) * E3_V;
    %Infected
    dI_V= 3 * parameter.sigma_V * E3_V - (parameter.mu_V + parameter.alpha * f_T) * I_V;

    dPop = [dS_H; dE_H; dI1_H; dI2_H; dR_H; dP_V; dS_V; dG_V; dE1_V; dE2_V; dE3_V; dI_V];
    end
end